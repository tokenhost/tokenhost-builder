import fs from 'fs';
import os from 'os';
import path from 'path';
import crypto from 'crypto';
import { spawnSync } from 'child_process';
import { createRequire } from 'module';
import { fileURLToPath, pathToFileURL } from 'url';
import { Command } from 'commander';

import { generateAppSolidity } from '@tokenhost/generator';
import {
  computeSchemaHash,
  importLegacyContractsJson,
  lintThs,
  listThsMigrations,
  migrateThsSchema,
  validateThsStructural,
  type Issue,
  type ThsSchema
} from '@tokenhost/schema';

import { createPublicClient, createWalletClient, encodeAbiParameters, http, isAddress, isHex, keccak256, toBytes, type Address, type Hex } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { anvil, sepolia } from 'viem/chains';

const require = createRequire(import.meta.url);
const Ajv2020 = require('ajv/dist/2020') as typeof import('ajv/dist/2020.js').default;
const addFormats = require('ajv-formats') as any;
const solc = require('solc') as any;

function readJsonFile(filePath: string): unknown {
  const raw = fs.readFileSync(filePath, 'utf-8');
  return JSON.parse(raw);
}

function sha256Digest(data: Buffer | string): string {
  const hash = crypto.createHash('sha256').update(data).digest('hex');
  return `sha256:${hash}`;
}

function listFilesRecursive(dir: string): string[] {
  const out: string[] = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) out.push(...listFilesRecursive(full));
    if (entry.isFile()) out.push(full);
  }
  return out;
}

function computeDirectoryDigest(dir: string): string {
  const files = fs.existsSync(dir) ? listFilesRecursive(dir) : [];
  const entries = files
    .map((filePath) => {
      const rel = path.relative(dir, filePath).replace(/\\\\/g, '/');
      const digest = sha256Digest(fs.readFileSync(filePath));
      return { path: rel, digest };
    })
    .sort((a, b) => (a.path < b.path ? -1 : a.path > b.path ? 1 : 0));

  // RFC 8785 canonicalization + SHA-256 (SPEC 11.6.1).
  return computeSchemaHash({ version: 1, files: entries });
}

function formatIssues(issues: Issue[]): string {
  return issues
    .map((i) => `${i.severity.toUpperCase()} ${i.code} ${i.path} - ${i.message}`)
    .join('\n');
}

function ensureDir(dir: string) {
  fs.mkdirSync(dir, { recursive: true });
}

function copyDir(srcDir: string, destDir: string) {
  ensureDir(destDir);
  for (const entry of fs.readdirSync(srcDir, { withFileTypes: true })) {
    const src = path.join(srcDir, entry.name);
    const dst = path.join(destDir, entry.name);
    if (entry.isDirectory()) {
      // Avoid accidentally copying heavy build outputs if a template folder was used as a dev workspace.
      if (entry.name === 'node_modules' || entry.name === '.next' || entry.name === 'out') continue;
      copyDir(src, dst);
      continue;
    }
    if (entry.isFile()) {
      fs.copyFileSync(src, dst);
    }
  }
}

function resolveNextExportUiTemplateDir(): string {
  const here = path.dirname(fileURLToPath(import.meta.url));
  const candidates = [
    path.resolve(here, '../../templates/next-export-ui'),
    path.resolve(here, '../templates/next-export-ui'),
    path.resolve(here, 'templates/next-export-ui')
  ];

  for (const c of candidates) {
    if (fs.existsSync(path.join(c, 'package.json'))) return c;
  }

  const workspace = findUp('pnpm-workspace.yaml', process.cwd());
  if (workspace) {
    const root = path.dirname(workspace);
    const c = path.join(root, 'packages', 'templates', 'next-export-ui');
    if (fs.existsSync(path.join(c, 'package.json'))) return c;
  }

  throw new Error(
    `Could not find Next.js export UI template directory (next-export-ui).\nLooked in:\n${candidates
      .map((c) => `  - ${c}`)
      .join('\n')}`
  );
}

function toFileUrl(p: string): string {
  return pathToFileURL(path.resolve(p)).toString();
}

function ensureTrailingSlash(url: string): string {
  return url.endsWith('/') ? url : `${url}/`;
}

function runCommand(cmd: string, args: string[], opts?: { cwd?: string }) {
  const res = spawnSync(cmd, args, {
    cwd: opts?.cwd,
    stdio: 'inherit'
  });
  if (res.status !== 0) {
    throw new Error(`${cmd} ${args.join(' ')} failed with exit code ${res.status ?? 'unknown'}`);
  }
}

function renderThsTs(schema: ThsSchema): string {
  // Embed the full THS schema in the UI so it can render forms + routes without server-side code.
  return (
    `/*\n` +
    ` * GENERATED FILE\n` +
    ` *\n` +
    ` * This file is generated by \`th generate\` from the THS schema.\n` +
    ` */\n\n` +
    `export const ths = ${JSON.stringify(schema, null, 2)} as const;\n\n` +
    `export type Ths = typeof ths;\n`
  );
}

function loadManifestSigningKey(): crypto.KeyObject | null {
  const keyPath = process.env.TH_MANIFEST_SIGNING_KEY_PATH;
  if (keyPath) {
    const pem = fs.readFileSync(keyPath, 'utf-8');
    return crypto.createPrivateKey(pem);
  }

  const env = process.env.TH_MANIFEST_SIGNING_KEY || process.env.TH_MANIFEST_SIGNING_PRIVATE_KEY;
  if (!env) return null;

  const raw = env.trim();
  if (raw.startsWith('-----BEGIN')) {
    return crypto.createPrivateKey(raw);
  }

  // Assume base64-encoded PKCS#8 DER.
  const b64 = raw.startsWith('base64:') ? raw.slice('base64:'.length) : raw;
  const der = Buffer.from(b64, 'base64');
  return crypto.createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });
}

function computeKeyIdEd25519(privateKey: crypto.KeyObject): string {
  const pub = crypto.createPublicKey(privateKey);
  const spki = pub.export({ format: 'der', type: 'spki' }) as Buffer;
  return sha256Digest(spki);
}

function signManifest(manifest: any, privateKey: crypto.KeyObject): { alg: string; keyId: string; sig: string } {
  // Sign the canonical manifest digest of the manifest with signatures removed.
  // Verifiers should recompute this same digest before verifying.
  const unsigned = { ...manifest, signatures: [] };
  const digest = computeSchemaHash(unsigned);
  const signature = crypto.sign(null, Buffer.from(digest, 'utf-8'), privateKey);
  return {
    alg: 'ed25519',
    keyId: computeKeyIdEd25519(privateKey),
    sig: signature.toString('base64')
  };
}

function findUp(filename: string, startDir: string): string | null {
  let dir = path.resolve(startDir);
  while (true) {
    const candidate = path.join(dir, filename);
    if (fs.existsSync(candidate)) return candidate;
    const parent = path.dirname(dir);
    if (parent === dir) return null;
    dir = parent;
  }
}

function loadRepoSchema(relPath: string): unknown {
  const found = findUp(relPath, process.cwd());
  if (!found) {
    throw new Error(`Could not find ${relPath} (searched upward from ${process.cwd()})`);
  }
  return JSON.parse(fs.readFileSync(found, 'utf-8'));
}

function compileSolidity(sourcePath: string, contents: string, contractName: string): { abi: unknown; bytecode: string; deployedBytecode: string } {
  const input = {
    language: 'Solidity',
    sources: {
      [sourcePath]: { content: contents }
    },
    settings: {
      optimizer: { enabled: true, runs: 200 },
      outputSelection: {
        '*': {
          '*': ['abi', 'evm.bytecode.object', 'evm.deployedBytecode.object']
        }
      }
    }
  };

  const output = JSON.parse(solc.compile(JSON.stringify(input)));
  const errors = (output.errors || []).filter((e: any) => e.severity === 'error');
  if (errors.length > 0) {
    const msg = errors.map((e: any) => e.formattedMessage || e.message).join('\n');
    throw new Error(`Solidity compile failed:\n${msg}`);
  }

  const compiled = output.contracts?.[sourcePath]?.[contractName];
  if (!compiled) {
    throw new Error(`Solidity compile output missing ${contractName} in ${sourcePath}`);
  }

  const abi = compiled.abi;
  const bytecode = `0x${compiled.evm.bytecode.object}`;
  const deployedBytecode = `0x${compiled.evm.deployedBytecode.object}`;
  return { abi, bytecode, deployedBytecode };
}

function titleFromSlug(slug: string): string {
  return slug
    .split(/[-_]+/g)
    .filter(Boolean)
    .map((p) => (p.length ? p[0]!.toUpperCase() + p.slice(1) : p))
    .join(' ');
}

type KnownChainName = 'anvil' | 'sepolia';

function resolveKnownChain(name: string): { chainName: KnownChainName; chain: any } {
  const n = name.toLowerCase();
  if (n === 'anvil') return { chainName: 'anvil', chain: anvil };
  if (n === 'sepolia') return { chainName: 'sepolia', chain: sepolia };
  throw new Error(`Unknown chain "${name}". Supported: anvil, sepolia`);
}

function envKeyForChain(chainName: KnownChainName, suffix: string): string {
  return `${chainName.toUpperCase()}_${suffix}`;
}

function resolveRpcUrl(chainName: KnownChainName, chain: any, override?: string): string {
  if (override) return override;
  const env = process.env[envKeyForChain(chainName, 'RPC_URL')] || process.env.TH_RPC_URL;
  if (env) return env;
  const fromChain = chain?.rpcUrls?.default?.http?.[0];
  if (fromChain) return fromChain;
  throw new Error(`No RPC URL configured. Provide --rpc or set ${envKeyForChain(chainName, 'RPC_URL')} / TH_RPC_URL.`);
}

function buildChainConfigArtifact(args: { chainName: KnownChainName; chain: any; rpcUrl: string }): any {
  const now = new Date().toISOString();
  const isLocal = args.chainName === 'anvil';

  const chainConfig: any = {
    chainConfigVersion: '1.0.0',
    chainId: args.chain.id,
    name: String(args.chain?.name ?? args.chainName),
    type: 'external-evm',
    nativeCurrency: {
      name: String(args.chain?.nativeCurrency?.name ?? 'Native'),
      symbol: String(args.chain?.nativeCurrency?.symbol ?? 'NATIVE'),
      decimals: Number(args.chain?.nativeCurrency?.decimals ?? 18)
    },
    trust: isLocal ? { posture: 'external', notes: 'Local dev chain' } : { posture: 'external' },
    finality: {
      model: isLocal ? 'instant' : 'probabilistic',
      recommendedConfirmations: isLocal ? 0 : 2,
      typicalSeconds: isLocal ? 1 : 12
    },
    rpc: {
      endpoints: [
        {
          url: args.rpcUrl,
          kind: 'public',
          priority: 0,
          capabilities: {
            batching: true,
            subscriptions: args.rpcUrl.startsWith('ws') || args.rpcUrl.startsWith('wss')
          }
        }
      ]
    },
    issuer: {
      name: 'Token Host (local)',
      issuedAt: now
    },
    signatures: [{ alg: 'none', sig: 'UNSIGNED' }]
  };

  if (args.chainName === 'sepolia') {
    chainConfig.explorers = [
      {
        name: 'Etherscan',
        url: 'https://sepolia.etherscan.io',
        apiUrl: 'https://api-sepolia.etherscan.io/api'
      }
    ];
  }

  return chainConfig;
}

const ANVIL_DEFAULT_PRIVATE_KEY: Hex = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';

function normalizePrivateKey(privateKey: string): Hex {
  const trimmed = privateKey.trim();
  const hex = trimmed.startsWith('0x') ? trimmed : `0x${trimmed}`;
  if (!/^0x[0-9a-fA-F]{64}$/.test(hex)) {
    throw new Error('Invalid private key. Expected 32-byte hex string (0x + 64 hex chars).');
  }
  return hex as Hex;
}

function normalizeHexString(value: string, label: string): Hex {
  const trimmed = value.trim();
  const hex = trimmed.startsWith('0x') ? trimmed : `0x${trimmed}`;
  if (!isHex(hex)) throw new Error(`Invalid ${label} hex string.`);
  return hex as Hex;
}

function resolvePrivateKey(chainName: KnownChainName, override?: string): Hex {
  if (override) return normalizePrivateKey(override);

  const chainSpecific = process.env[envKeyForChain(chainName, 'PRIVATE_KEY')];
  if (chainSpecific) return normalizePrivateKey(chainSpecific);

  // Convenience for local dev. Avoid accidentally using a real PRIVATE_KEY on anvil.
  if (chainName === 'anvil') return ANVIL_DEFAULT_PRIVATE_KEY;

  const env = process.env.TH_PRIVATE_KEY || process.env.PRIVATE_KEY;
  if (env) return normalizePrivateKey(env);

  throw new Error(`Missing private key. Provide --private-key or set ${envKeyForChain(chainName, 'PRIVATE_KEY')} / TH_PRIVATE_KEY / PRIVATE_KEY.`);
}

function normalizeAddress(addr: string, label: string): Address {
  const trimmed = addr.trim();
  if (!isAddress(trimmed)) throw new Error(`Invalid ${label} address: ${addr}`);
  return trimmed as Address;
}

function findConstructorInputs(abi: any): any[] {
  if (!Array.isArray(abi)) return [];
  const ctor = abi.find((x) => x && typeof x === 'object' && x.type === 'constructor');
  return Array.isArray(ctor?.inputs) ? ctor.inputs : [];
}

function loadManifestSchema(): any {
  return loadRepoSchema('schemas/tokenhost-release-manifest.schema.json');
}

function validateManifest(manifest: any): { ok: boolean; errors: unknown } {
  const manifestSchema = loadManifestSchema();
  const ajv = new Ajv2020({ allErrors: true, strict: false });
  // Add standard JSON Schema format support (uri, date-time, ...).
  addFormats(ajv);
  const validate = ajv.compile(manifestSchema as any);
  const ok = Boolean(validate(manifest));
  return { ok, errors: validate.errors };
}

function loadChainConfigSchema(): any {
  return loadRepoSchema('schemas/tokenhost-chain-config.schema.json');
}

function validateChainConfig(chainConfig: any): { ok: boolean; errors: unknown } {
  const chainSchema = loadChainConfigSchema();
  const ajv = new Ajv2020({ allErrors: true, strict: false });
  addFormats(ajv);
  const validate = ajv.compile(chainSchema as any);
  const ok = Boolean(validate(chainConfig));
  return { ok, errors: validate.errors };
}

const program = new Command();

program.name('th').description('Token Host CLI (local)').version('0.0.0');

program
  .command('init')
  .argument('<slug>', 'App slug (used in URLs/domains)')
  .option('--name <name>', 'App display name (defaults from slug)')
  .option('--thsVersion <v>', 'THS document format version', '2025-12')
  .option('--schemaVersion <v>', 'Initial schema version', '0.0.1')
  .option('--dir <dir>', 'Output directory (defaults to apps/<slug>)')
  .action((slug: string, opts: { name?: string; thsVersion: string; schemaVersion: string; dir?: string }) => {
    const outDir = opts.dir ? opts.dir : path.join('apps', slug);
    ensureDir(outDir);

    const schema: ThsSchema = {
      thsVersion: opts.thsVersion,
      schemaVersion: opts.schemaVersion,
      app: {
        name: opts.name ?? titleFromSlug(slug),
        slug,
        features: {
          uploads: false,
          onChainIndexing: true
        }
      },
      collections: [
        {
          name: 'Item',
          fields: [{ name: 'title', type: 'string', required: true }],
          createRules: { required: ['title'], access: 'public' },
          visibilityRules: { gets: ['title'], access: 'public' },
          updateRules: { mutable: ['title'], access: 'owner' },
          deleteRules: { softDelete: true, access: 'owner' },
          indexes: { unique: [], index: [] }
        }
      ]
    };

    const schemaPath = path.join(outDir, 'schema.json');
    fs.writeFileSync(schemaPath, JSON.stringify(schema, null, 2));

    const readmePath = path.join(outDir, 'README.md');
    fs.writeFileSync(
      readmePath,
      [
        `# ${schema.app.name}`,
        '',
        '## Quickstart',
        '',
        '```bash',
        `pnpm th validate ${schemaPath}`,
        `pnpm th build ${schemaPath} --out ${path.join(outDir, 'build')}`,
        `pnpm th deploy ${path.join(outDir, 'build')} --chain anvil`,
        '```',
        ''
      ].join('\n')
    );

    console.log(`Wrote ${schemaPath}`);
    console.log(`Wrote ${readmePath}`);
  });

program
  .command('doctor')
  .description('Check local environment readiness')
  .action(() => {
    let ok = true;

    const nodeMajor = Number(process.versions.node.split('.')[0] || 0);
    if (nodeMajor < 20) {
      ok = false;
      console.error(`ERROR node: ${process.versions.node} (need >= 20)`);
    } else {
      console.log(`OK node: ${process.versions.node}`);
    }

    try {
      const v = solc.version?.() || 'unknown';
      console.log(`OK solc-js: ${v}`);
    } catch {
      ok = false;
      console.error('ERROR solc-js: failed to load');
    }

    for (const tool of ['anvil', 'forge'] as const) {
      const res = spawnSync(tool, ['--version'], { encoding: 'utf-8' });
      if (res.status === 0) {
        const line = (res.stdout || res.stderr || '').trim().split('\n')[0] || '';
        console.log(`OK ${tool}: ${line}`);
      } else {
        // Foundry is optional for pure build/compile, but required for some workflows.
        console.warn(`WARN ${tool}: not found or not runnable`);
      }
    }

    if (!ok) process.exitCode = 1;
  });

program
  .command('validate')
  .argument('<schema>', 'Path to THS schema JSON file')
  .option('--json', 'Output machine-readable JSON', false)
  .action((schemaPath: string, opts: { json: boolean }) => {
    const input = readJsonFile(schemaPath);
    const structural = validateThsStructural(input);
    if (!structural.ok) {
      if (opts.json) {
        console.log(JSON.stringify({ ok: false, issues: structural.issues }, null, 2));
      } else {
        console.error(formatIssues(structural.issues));
      }
      process.exitCode = 1;
      return;
    }

    const schema = structural.data!;
    const lintIssues = lintThs(schema);
    const schemaHash = computeSchemaHash(schema);

    const errors = lintIssues.filter((i) => i.severity === 'error');
    if (opts.json) {
      console.log(JSON.stringify({ ok: errors.length === 0, schemaHash, issues: lintIssues }, null, 2));
    } else {
      if (lintIssues.length > 0) console.log(formatIssues(lintIssues));
      console.log(`schemaHash: ${schemaHash}`);
    }

    if (errors.length > 0) process.exitCode = 1;
  });

program
  .command('import-legacy')
  .argument('<contractsJson>', 'Path to legacy contracts.json')
  .option('--thsVersion <v>', 'THS document format version', '2025-12')
  .option('--schemaVersion <v>', 'App schema version', '0.0.0')
  .option('--appName <name>', 'App name', 'Imported App')
  .option('--appSlug <slug>', 'App slug', 'imported-app')
  .option('--out <file>', 'Write output schema JSON to a file (defaults to stdout)')
  .action((legacyPath: string, opts: { thsVersion: string; schemaVersion: string; appName: string; appSlug: string; out?: string }) => {
    const input = readJsonFile(legacyPath) as any;
    const ths = importLegacyContractsJson(input, {
      thsVersion: opts.thsVersion,
      schemaVersion: opts.schemaVersion,
      appName: opts.appName,
      appSlug: opts.appSlug
    });
    const out = JSON.stringify(ths, null, 2);
    if (opts.out) {
      ensureDir(path.dirname(opts.out));
      fs.writeFileSync(opts.out, out);
    } else {
      console.log(out);
    }
  });

program
  .command('generate')
  .argument('<schema>', 'Path to THS schema JSON file')
  .option('--out <dir>', 'Output directory', 'artifacts')
  .option('--no-ui', 'Do not generate UI output')
  .action((schemaPath: string, opts: { out: string; ui: boolean }) => {
    const input = readJsonFile(schemaPath);
    const structural = validateThsStructural(input);
    if (!structural.ok) {
      console.error(formatIssues(structural.issues));
      process.exitCode = 1;
      return;
    }

    const schema = structural.data!;
    const lintIssues = lintThs(schema);
    const errors = lintIssues.filter((i) => i.severity === 'error');
    if (errors.length > 0) {
      console.error(formatIssues(lintIssues));
      process.exitCode = 1;
      return;
    }

    const outDir = opts.out;
    const appSol = generateAppSolidity(schema);
    const contractsDir = path.join(outDir, path.dirname(appSol.path));
    ensureDir(contractsDir);
    fs.writeFileSync(path.join(outDir, appSol.path), appSol.contents);

    // Also persist an immutable copy of the schema input alongside the artifacts.
    ensureDir(outDir);
    fs.writeFileSync(path.join(outDir, 'schema.json'), JSON.stringify(schema, null, 2));

    if (opts.ui) {
      const templateDir = resolveNextExportUiTemplateDir();
      const uiDir = path.join(outDir, 'ui');
      copyDir(templateDir, uiDir);

      const thsTsPath = path.join(uiDir, 'src', 'generated', 'ths.ts');
      ensureDir(path.dirname(thsTsPath));
      fs.writeFileSync(thsTsPath, renderThsTs(schema));

      console.log(`Wrote ui/ (Next.js static export template)`);
    }

    console.log(`Wrote ${appSol.path}`);
  });

program
  .command('build')
  .argument('<schema>', 'Path to THS schema JSON file')
  .option('--out <dir>', 'Output directory', 'artifacts')
  .option('--no-ui', 'Do not generate/build UI bundle')
  .action((schemaPath: string, opts: { out: string; ui: boolean }) => {
    const input = readJsonFile(schemaPath);
    const structural = validateThsStructural(input);
    if (!structural.ok) {
      console.error(formatIssues(structural.issues));
      process.exitCode = 1;
      return;
    }

    const schema = structural.data!;
    const lintIssues = lintThs(schema);
    const errors = lintIssues.filter((i) => i.severity === 'error');
    if (errors.length > 0) {
      console.error(formatIssues(lintIssues));
      process.exitCode = 1;
      return;
    }

    const outDir = opts.out;
    ensureDir(outDir);

    // 1) Generate Solidity source
    const appSol = generateAppSolidity(schema);
    ensureDir(path.join(outDir, path.dirname(appSol.path)));
    fs.writeFileSync(path.join(outDir, appSol.path), appSol.contents);

    // 2) Compile (solc-js)
    const sourceRelPath = appSol.path.replace(/\\\\/g, '/');
    const compiled = compileSolidity(sourceRelPath, appSol.contents, 'App');
    const compiledArtifact = {
      contractName: 'App',
      abi: compiled.abi,
      bytecode: compiled.bytecode,
      deployedBytecode: compiled.deployedBytecode
    };
    const compiledJson = JSON.stringify(compiledArtifact, null, 2);
    const compiledOutPath = path.join(outDir, 'compiled', 'App.json');
    ensureDir(path.dirname(compiledOutPath));
    fs.writeFileSync(compiledOutPath, compiledJson);

    // 3) Write schema copy
    fs.writeFileSync(path.join(outDir, 'schema.json'), JSON.stringify(schema, null, 2));

    // 4) Package build artifacts (SPEC 11)
    const sourcesTgzPath = path.join(outDir, 'sources.tgz');
    const compiledTgzPath = path.join(outDir, 'compiled.tgz');
    runCommand('tar', ['-czf', sourcesTgzPath, '-C', outDir, path.dirname(appSol.path)]);
    runCommand('tar', ['-czf', compiledTgzPath, '-C', outDir, 'compiled']);

    // 5) Build UI bundle (Next.js static export) (SPEC 8 / 11)
    const emptyUiBundleDigest = computeSchemaHash({ version: 1, files: [] });
    let uiBundleDigest = emptyUiBundleDigest;
    let uiBaseUrl = ensureTrailingSlash(process.env.TH_UI_BASE_URL ?? 'http://localhost/');
    let uiBundleDir: string | null = null;
    let uiSiteDir: string | null = null;

    if (opts.ui) {
      uiBundleDir = path.join(outDir, 'ui-bundle');
      uiSiteDir = path.join(outDir, 'ui-site');
      fs.rmSync(uiBundleDir, { recursive: true, force: true });
      ensureDir(uiBundleDir);

      const uiWorkDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tokenhost-ui-build-'));
      try {
        const templateDir = resolveNextExportUiTemplateDir();
        copyDir(templateDir, uiWorkDir);

        // Inject schema for client-side routing/forms.
        const thsTsPath = path.join(uiWorkDir, 'src', 'generated', 'ths.ts');
        ensureDir(path.dirname(thsTsPath));
        fs.writeFileSync(thsTsPath, renderThsTs(schema));

        // Ship ABI alongside the UI so it can operate without additional servers.
        const compiledPublicPath = path.join(uiWorkDir, 'public', 'compiled', 'App.json');
        ensureDir(path.dirname(compiledPublicPath));
        fs.writeFileSync(compiledPublicPath, compiledJson);

        // Do not bake a manifest into the UI bundle; it is published separately and signed.
        const bakedManifestPath = path.join(uiWorkDir, 'public', '.well-known', 'tokenhost', 'manifest.json');
        if (fs.existsSync(bakedManifestPath)) fs.rmSync(bakedManifestPath, { force: true });

        runCommand('pnpm', ['install'], { cwd: uiWorkDir });
        runCommand('pnpm', ['build'], { cwd: uiWorkDir });

        const exportedDir = path.join(uiWorkDir, 'out');
        if (!fs.existsSync(exportedDir)) {
          throw new Error(`UI build did not produce an export directory at ${exportedDir}.`);
        }

        // Copy the static export output into the build output directory.
        copyDir(exportedDir, uiBundleDir);
      } finally {
        fs.rmSync(uiWorkDir, { recursive: true, force: true });
      }

      uiBundleDigest = computeDirectoryDigest(uiBundleDir);
      uiBaseUrl = ensureTrailingSlash(process.env.TH_UI_BASE_URL ?? toFileUrl(uiSiteDir));
    }

    // 6) Build a local manifest. This is spec-shaped but uses placeholder deployments
    // until `th deploy` updates it.
    const schemaHash = computeSchemaHash(schema);
    const sourcesDigest = computeDirectoryDigest(path.join(outDir, path.dirname(appSol.path)));
    const compiledDigest = computeDirectoryDigest(path.join(outDir, 'compiled'));
    const abiDigest = sha256Digest(JSON.stringify(compiled.abi));
    const bytecodeDigest = sha256Digest(compiled.bytecode);

    const features = {
      indexer: schema.app.features?.indexer ?? false,
      delegation: schema.app.features?.delegation ?? false,
      uploads: schema.app.features?.uploads ?? false,
      onChainIndexing: schema.app.features?.onChainIndexing ?? true
    };

    const collections = schema.collections.map((c) => ({
      name: c.name,
      collectionId: keccak256(toBytes(c.name))
    }));

    const zeroAddress = '0x0000000000000000000000000000000000000000';

    const manifest = {
      manifestVersion: '0.1.0',
      thsVersion: schema.thsVersion,
      schemaVersion: schema.schemaVersion,
      schemaHash,
      generatorVersion: '0.0.0',
      toolchain: {
        node: process.version.replace(/^v/, ''),
        solc: solc.version()
      },
      release: {
        releaseId: `rel_local_${Date.now()}`,
        supersedesReleaseId: null,
        publishedAt: new Date().toISOString()
      },
      app: {
        name: schema.app.name,
        slug: schema.app.slug
      },
      collections,
      artifacts: {
        soliditySources: { digest: sourcesDigest, url: toFileUrl(sourcesTgzPath) },
        compiledContracts: { digest: compiledDigest, url: toFileUrl(compiledTgzPath) }
      },
      deployments: [
        {
          role: 'primary',
          chainId: 31337,
          chainName: 'local',
          deploymentMode: 'single',
          deploymentEntrypointAddress: zeroAddress,
          adminAddress: zeroAddress,
          treasuryAddress: anyPaidCreates(schema) ? zeroAddress : null,
          contracts: [
            {
              role: 'app',
              address: zeroAddress,
              verified: false,
              bytecodeDigest,
              abiDigest
            }
          ],
          verified: false,
          blockNumber: 0
        }
      ],
      ui: {
        bundleHash: uiBundleDigest,
        baseUrl: uiBaseUrl,
        wellKnown: '/.well-known/tokenhost/manifest.json'
      },
      features,
      signatures: [{ alg: 'none', sig: 'UNSIGNED' }]
    };

    const signingKey = loadManifestSigningKey();
    if (signingKey) {
      manifest.signatures = [signManifest(manifest, signingKey)];
    }

    // Validate manifest shape against the local JSON schema.
    const { ok, errors: manifestErrors } = validateManifest(manifest);
    if (!ok) {
      console.error('Generated manifest did not validate against schemas/tokenhost-release-manifest.schema.json');
      console.error(JSON.stringify(manifestErrors, null, 2));
      process.exitCode = 1;
      return;
    }

    const manifestPath = path.join(outDir, 'manifest.json');
    const manifestJsonOut = JSON.stringify(manifest, null, 2);
    fs.writeFileSync(manifestPath, manifestJsonOut);

    // Convenience: create a self-hostable static site root that includes the UI bundle + manifest.
    // Note: ui.bundleHash is computed over ui-bundle/ (UI code only), not this directory.
    if (uiBundleDir && uiSiteDir) {
      fs.rmSync(uiSiteDir, { recursive: true, force: true });
      copyDir(uiBundleDir, uiSiteDir);
      ensureDir(path.join(uiSiteDir, '.well-known', 'tokenhost'));
      fs.writeFileSync(path.join(uiSiteDir, '.well-known', 'tokenhost', 'manifest.json'), manifestJsonOut);
      fs.writeFileSync(path.join(uiSiteDir, 'manifest.json'), manifestJsonOut);
    }
    console.log(`Wrote ${appSol.path}`);
    console.log(`Wrote compiled/App.json`);
    console.log(`Wrote sources.tgz`);
    console.log(`Wrote compiled.tgz`);
    if (uiBundleDir) {
      console.log(`Wrote ui-bundle/ (digest: ${uiBundleDigest})`);
      console.log(`Wrote ui-site/ (self-hostable static root)`);
    }
    console.log(`Wrote manifest.json`);
  });

function anyPaidCreates(schema: ThsSchema): boolean {
  return schema.collections.some((c) => Boolean(c.createRules.payment));
}

program
  .command('deploy')
  .argument('<buildDir>', 'Directory created by `th build` (contains manifest.json)')
  .option('--chain <name>', 'Chain name (anvil|sepolia)', 'anvil')
  .option('--rpc <url>', 'RPC URL override')
  .option('--private-key <hex>', 'Private key (0x...) override')
  .option('--admin <address>', 'Admin address (defaults to deployer)')
  .option('--treasury <address>', 'Treasury address (defaults to deployer)')
  .option('--role <role>', 'Deployment role (primary|legacy)', 'primary')
  .action(async (buildDir: string, opts: { chain: string; rpc?: string; privateKey?: string; admin?: string; treasury?: string; role: string }) => {
    try {
      const resolvedBuildDir = path.resolve(buildDir);
      const manifestPath = path.join(resolvedBuildDir, 'manifest.json');
      const compiledPath = path.join(resolvedBuildDir, 'compiled', 'App.json');
      const schemaPath = path.join(resolvedBuildDir, 'schema.json');

      if (!fs.existsSync(manifestPath)) throw new Error(`Missing manifest.json in ${resolvedBuildDir}. Run \`th build\` first.`);
      if (!fs.existsSync(compiledPath)) throw new Error(`Missing compiled/App.json in ${resolvedBuildDir}. Run \`th build\` first.`);
      if (!fs.existsSync(schemaPath)) throw new Error(`Missing schema.json in ${resolvedBuildDir}. Run \`th build\` first.`);

      const manifest = readJsonFile(manifestPath) as any;
      const compiled = readJsonFile(compiledPath) as any;
      const schemaInput = readJsonFile(schemaPath);
      const schemaStructural = validateThsStructural(schemaInput);
      if (!schemaStructural.ok) throw new Error(`Invalid schema.json in buildDir:\n${formatIssues(schemaStructural.issues)}`);
      const schema = schemaStructural.data!;

      const { chainName, chain } = resolveKnownChain(opts.chain);
      const rpcUrl = resolveRpcUrl(chainName, chain, opts.rpc);
      const privateKey = resolvePrivateKey(chainName, opts.privateKey);
      const account = privateKeyToAccount(privateKey);

      const walletClient = createWalletClient({
        chain,
        account,
        transport: http(rpcUrl)
      });
      const publicClient = createPublicClient({
        chain,
        transport: http(rpcUrl)
      });

      const abi = compiled.abi;
      const bytecode: Hex = normalizeHexString(String(compiled.bytecode), 'bytecode');
      const ctorInputs = findConstructorInputs(abi);

      const deployer = account.address as Address;
      const admin = normalizeAddress(opts.admin ?? deployer, 'admin');
      const treasury = normalizeAddress(opts.treasury ?? deployer, 'treasury');

      const args = (() => {
        if (ctorInputs.length === 0) return [];
        if (ctorInputs.length === 2) return [admin, treasury];
        throw new Error(`Unsupported constructor arity (${ctorInputs.length}).`);
      })();

      console.log(`Deploying App to ${chainName} (${rpcUrl}) as ${deployer}...`);

      const txHash = await walletClient.deployContract({
        abi,
        bytecode,
        args,
        chain
      });

      const receipt = await publicClient.waitForTransactionReceipt({ hash: txHash });
      const deployedAddress = receipt.contractAddress;
      if (!deployedAddress) throw new Error('Deployment receipt missing contractAddress.');

      console.log(`Deployed App: ${deployedAddress}`);

      const bytecodeDigest = sha256Digest(String(compiled.bytecode));
      const abiDigest = sha256Digest(JSON.stringify(abi));

      const deployment = {
        role: opts.role,
        chainId: chain.id,
        chainName,
        deploymentMode: 'single',
        deploymentEntrypointAddress: deployedAddress,
        adminAddress: admin,
        treasuryAddress: ctorInputs.length === 2 ? treasury : null,
        contracts: [
          {
            role: 'app',
            address: deployedAddress,
            verified: false,
            bytecodeDigest,
            abiDigest
          }
        ],
        verified: false,
        blockNumber: Number(receipt.blockNumber ?? 0n)
      };

      // Emit a chain config artifact and reference it from this deployment.
      const chainConfig = buildChainConfigArtifact({ chainName, chain, rpcUrl });
      const chainSigningKey = loadManifestSigningKey();
      if (chainSigningKey) {
        chainConfig.signatures = [signManifest(chainConfig, chainSigningKey)];
      }
      const chainCfgValidation = validateChainConfig(chainConfig);
      if (!chainCfgValidation.ok) {
        throw new Error(`Generated chain config did not validate:\n${JSON.stringify(chainCfgValidation.errors, null, 2)}`);
      }

      const chainConfigDir = path.join(resolvedBuildDir, 'chain-config');
      ensureDir(chainConfigDir);
      const chainConfigPath = path.join(chainConfigDir, `${chainName}.json`);
      fs.writeFileSync(chainConfigPath, JSON.stringify(chainConfig, null, 2));
      const chainConfigDigest = computeSchemaHash(chainConfig);
      (deployment as any).chainConfig = {
        url: toFileUrl(chainConfigPath),
        digest: chainConfigDigest,
        chainConfigVersion: chainConfig.chainConfigVersion
      };

      // Replace existing deployment entry for (role, chainId) if it exists; otherwise append.
      manifest.deployments = Array.isArray(manifest.deployments) ? manifest.deployments : [];
      const zeroAddress = '0x0000000000000000000000000000000000000000';
      const byRoleAndChainIdx = manifest.deployments.findIndex((d: any) => d && d.role === opts.role && d.chainId === chain.id);
      const placeholderIdx =
        byRoleAndChainIdx >= 0
          ? -1
          : manifest.deployments.findIndex(
              (d: any) => d && d.role === opts.role && String(d.deploymentEntrypointAddress || '').toLowerCase() === zeroAddress
            );
      const idx = byRoleAndChainIdx >= 0 ? byRoleAndChainIdx : placeholderIdx;
      if (idx >= 0) {
        manifest.deployments[idx] = deployment;
      } else {
        manifest.deployments.push(deployment);
      }

      // If the schema includes paid creates, make sure treasury is not null in manifest.
      if (anyPaidCreates(schema) && deployment.treasuryAddress === null) {
        throw new Error('Schema includes paid creates, but deployed contract has no treasuryAddress constructor.');
      }

      // Re-sign manifest after mutating deployments.
      const signingKey = loadManifestSigningKey();
      if (signingKey) {
        manifest.signatures = [signManifest(manifest, signingKey)];
      } else {
        const hadRealSig = Array.isArray(manifest.signatures) && manifest.signatures.some((s: any) => s && s.alg && s.alg !== 'none');
        if (hadRealSig) {
          console.warn('WARN manifest: signing key not provided; clearing signatures and marking UNSIGNED');
        }
        manifest.signatures = [{ alg: 'none', sig: 'UNSIGNED' }];
      }

      const validation = validateManifest(manifest);
      if (!validation.ok) {
        throw new Error(`Updated manifest failed validation:\n${JSON.stringify(validation.errors, null, 2)}`);
      }

      fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
      console.log(`Updated ${manifestPath}`);
    } catch (e: any) {
      console.error(String(e?.message ?? e));
      process.exitCode = 1;
    }
  });

program
  .command('verify')
  .argument('<buildDir>', 'Directory created by `th build` (contains manifest.json)')
  .description('Verify deployed contracts on explorers (Etherscan + Sourcify)')
  .option('--chain <name>', 'Chain name (anvil|sepolia)', 'sepolia')
  .option('--rpc <url>', 'RPC URL override (used by verifier tooling)')
  .option('--verifier <v>', 'Verifier to use (etherscan|sourcify|both)', 'both')
  .option('--etherscan-api-key <key>', 'Etherscan API key override')
  .option('--no-watch', 'Do not wait for verification results')
  .action((buildDir: string, opts: { chain: string; rpc?: string; verifier: string; etherscanApiKey?: string; watch: boolean }) => {
    const resolvedBuildDir = path.resolve(buildDir);
    const manifestPath = path.join(resolvedBuildDir, 'manifest.json');
    const compiledPath = path.join(resolvedBuildDir, 'compiled', 'App.json');
    const sourcePath = path.join(resolvedBuildDir, 'contracts', 'App.sol');

    if (!fs.existsSync(manifestPath)) {
      console.error(`Missing manifest.json in ${resolvedBuildDir}. Run \`th build\` first.`);
      process.exitCode = 1;
      return;
    }
    if (!fs.existsSync(compiledPath)) {
      console.error(`Missing compiled/App.json in ${resolvedBuildDir}. Run \`th build\` first.`);
      process.exitCode = 1;
      return;
    }
    if (!fs.existsSync(sourcePath)) {
      console.error(`Missing contracts/App.sol in ${resolvedBuildDir}. Run \`th build\` first.`);
      process.exitCode = 1;
      return;
    }

    const manifest = readJsonFile(manifestPath) as any;
    const compiled = readJsonFile(compiledPath) as any;
    const source = fs.readFileSync(sourcePath, 'utf-8');

    const { chainName, chain } = resolveKnownChain(opts.chain);
    const rpcUrl = resolveRpcUrl(chainName, chain, opts.rpc);

    const deployments = Array.isArray(manifest.deployments) ? manifest.deployments : [];
    const target = deployments.find((d: any) => d && d.role === 'primary' && d.chainId === chain.id);
    if (!target) {
      console.error(`No primary deployment found for chainId ${chain.id} in manifest.json`);
      process.exitCode = 1;
      return;
    }

    const addr = String(target.deploymentEntrypointAddress || '');
    const zeroAddress = '0x0000000000000000000000000000000000000000';
    if (addr.toLowerCase() === zeroAddress) {
      console.error('deploymentEntrypointAddress is 0x0. Run `th deploy` first.');
      process.exitCode = 1;
      return;
    }
    const contractAddress = normalizeAddress(addr, 'deploymentEntrypointAddress');

    const verifier = String(opts.verifier || 'both').toLowerCase();
    const wantEtherscan = verifier === 'both' || verifier === 'etherscan';
    const wantSourcify = verifier === 'both' || verifier === 'sourcify';

    const etherscanKey = (() => {
      if (!wantEtherscan) return null;
      if (opts.etherscanApiKey) return opts.etherscanApiKey;
      return process.env[envKeyForChain(chainName, 'ETHERSCAN_API_KEY')] || process.env.ETHERSCAN_API_KEY || null;
    })();

    if (wantEtherscan && !etherscanKey) {
      console.error(`Missing Etherscan API key. Set ${envKeyForChain(chainName, 'ETHERSCAN_API_KEY')} or ETHERSCAN_API_KEY (or pass --etherscan-api-key).`);
      process.exitCode = 1;
      return;
    }

    // Encode constructor args if needed.
    const ctorInputs = findConstructorInputs(compiled?.abi);
    const ctorArgsEncoded = (() => {
      if (ctorInputs.length === 0) return null;
      if (ctorInputs.length === 2) {
        const adminAddress = normalizeAddress(String(target.adminAddress || ''), 'adminAddress');
        const treasuryAddress = normalizeAddress(String(target.treasuryAddress || ''), 'treasuryAddress');
        const params = ctorInputs.map((i: any) => ({ type: String(i.type) }));
        return encodeAbiParameters(params as any, [adminAddress, treasuryAddress] as any);
      }
      throw new Error(`Unsupported constructor arity for verification (${ctorInputs.length}).`);
    })();

    const verifyRoot = fs.mkdtempSync(path.join(os.tmpdir(), 'tokenhost-verify-'));
    const foundryToml = [
      '[profile.default]',
      'src = "contracts"',
      'out = "out"',
      'libs = ["lib"]',
      'solc_version = "0.8.24"',
      'optimizer = true',
      'optimizer_runs = 200',
      ''
    ].join('\n');

    let etherscanOk = false;
    let sourcifyOk = false;

    function runForge(args: string[]): boolean {
      const res = spawnSync('forge', args, { stdio: 'inherit' });
      return res.status === 0;
    }

    try {
      ensureDir(path.join(verifyRoot, 'contracts'));
      fs.writeFileSync(path.join(verifyRoot, 'contracts', 'App.sol'), source);
      fs.writeFileSync(path.join(verifyRoot, 'foundry.toml'), foundryToml);

      const contractId = 'contracts/App.sol:App';
      const commonArgs: string[] = [
        'verify-contract',
        '--root',
        verifyRoot,
        '--chain',
        String(chain.id),
        '--rpc-url',
        rpcUrl,
        '--compiler-version',
        '0.8.24',
        '--num-of-optimizations',
        '200'
      ];

      if (opts.watch) commonArgs.push('--watch');
      if (ctorArgsEncoded) commonArgs.push('--constructor-args', ctorArgsEncoded);

      if (wantEtherscan) {
        console.log(`Verifying on Etherscan (${chainName})...`);
        etherscanOk = runForge([
          ...commonArgs,
          '--verifier',
          'etherscan',
          '--etherscan-api-key',
          String(etherscanKey),
          contractAddress,
          contractId
        ]);
      }

      if (wantSourcify) {
        console.log(`Verifying on Sourcify (${chainName})...`);
        sourcifyOk = runForge([...commonArgs, '--verifier', 'sourcify', contractAddress, contractId]);
      }
    } catch (e: any) {
      console.error(String(e?.message ?? e));
      process.exitCode = 1;
      return;
    } finally {
      fs.rmSync(verifyRoot, { recursive: true, force: true });
    }

    const verified = (wantEtherscan ? etherscanOk : true) && (wantSourcify ? sourcifyOk : true);

    // Update manifest verification flags.
    target.verified = verified;
    if (Array.isArray(target.contracts)) {
      for (const c of target.contracts) c.verified = verified;
    }

    manifest.extensions = manifest.extensions ?? {};
    manifest.extensions.verification = {
      ...(manifest.extensions.verification ?? {}),
      [String(chain.id)]: {
        at: new Date().toISOString(),
        etherscan: wantEtherscan ? { ok: etherscanOk } : { ok: null },
        sourcify: wantSourcify ? { ok: sourcifyOk } : { ok: null }
      }
    };

    // Re-sign manifest after mutating verification status.
    const signingKey = loadManifestSigningKey();
    if (signingKey) {
      manifest.signatures = [signManifest(manifest, signingKey)];
    } else {
      manifest.signatures = [{ alg: 'none', sig: 'UNSIGNED' }];
    }

    const validation = validateManifest(manifest);
    if (!validation.ok) {
      console.error(`Updated manifest failed validation:\n${JSON.stringify(validation.errors, null, 2)}`);
      process.exitCode = 1;
      return;
    }

    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));

    if (!verified) {
      console.error('Verification did not fully succeed.');
      process.exitCode = 1;
      return;
    }

    console.log(`Verified and updated ${manifestPath}`);
  });

program
  .command('migrate')
  .argument('<schema>', 'Path to THS schema JSON file')
  .description('Apply local THS schema migrations')
  .option('--list', 'List known migrations and exit', false)
  .option('--down', 'Apply down migrations (revert)', false)
  .option('--steps <n>', 'Number of migrations to apply (default: all for up; 1 for down)')
  .option('--in-place', 'Overwrite the input schema file', false)
  .option('--out <file>', 'Write migrated schema JSON to a file (defaults to stdout)')
  .action((schemaPath: string, opts: { list: boolean; down: boolean; steps?: string; inPlace: boolean; out?: string }) => {
    if (opts.list) {
      const migrations = listThsMigrations();
      for (const m of migrations) {
        console.log(`${m.id} - ${m.description}`);
      }
      return;
    }

    if (opts.inPlace && opts.out) {
      console.error('ERROR: --in-place and --out are mutually exclusive.');
      process.exitCode = 1;
      return;
    }

    const input = readJsonFile(schemaPath);
    const structural = validateThsStructural(input);
    if (!structural.ok) {
      console.error(formatIssues(structural.issues));
      process.exitCode = 1;
      return;
    }

    const schema = structural.data!;

    const steps = (() => {
      if (typeof opts.steps !== 'string' || opts.steps.trim() === '') return undefined;
      const n = Number(opts.steps);
      if (!Number.isFinite(n) || n < 0) throw new Error('Invalid --steps value. Expected a non-negative number.');
      return Math.floor(n);
    })();

    const direction = opts.down ? 'down' : 'up';
    const effectiveSteps = steps ?? (direction === 'down' ? 1 : undefined);

    const res = migrateThsSchema(schema, { direction, steps: effectiveSteps });
    const migrated = res.schema;

    // Ensure the migrated schema still validates and lints cleanly.
    const lintIssues = lintThs(migrated);
    const errors = lintIssues.filter((i) => i.severity === 'error');
    if (errors.length > 0) {
      console.error(formatIssues(lintIssues));
      process.exitCode = 1;
      return;
    }

    const outJson = JSON.stringify(migrated, null, 2);
    if (opts.inPlace) {
      fs.writeFileSync(schemaPath, outJson);
    } else if (opts.out) {
      ensureDir(path.dirname(opts.out));
      fs.writeFileSync(opts.out, outJson);
    } else {
      console.log(outJson);
    }

    const appliedMsg = res.appliedNow.length > 0 ? res.appliedNow.join(', ') : '(none)';
    console.error(`migrations (${direction}) applied: ${appliedMsg}`);
  });

program
  .command('migrate-chain')
  .description('Migrate primary deployment to a new chain (stub)')
  .action(() => {
    console.error('th migrate-chain is not implemented yet.');
    process.exitCode = 1;
  });

program
  .command('indexer')
  .description('Generate/deploy indexer configuration (stub)')
  .action(() => {
    console.error('th indexer is not implemented yet.');
    process.exitCode = 1;
  });

await program.parseAsync(process.argv);
